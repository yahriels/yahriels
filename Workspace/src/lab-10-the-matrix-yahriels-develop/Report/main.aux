\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Exercise 3}{2}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Question 1}{2}{subsection.1.1}}
\@writefile{toc}{\contentsline {paragraph}{In comparing the performance and run time between the two solutions, I used Valgrind as instructed for all exercises to compare the failures in mode code. I learned that as the cache performance has a more accurate performance with the transposition while the run time decrease with the transposition.}{2}{section*.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Question 2}{2}{subsection.1.2}}
\@writefile{toc}{\contentsline {paragraph}{When running the calculation over and over again, the impact was noticeable in the matrices since the answers tended to differ slightly. Although the impact was not significant, one can see the differences between using the different solutions and methods.}{2}{section*.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}Question 3}{2}{subsection.1.3}}
\@writefile{toc}{\contentsline {paragraph}{Some ways this could impact larger programs includes decreasing the run time, producing different values from calculations, possibly decreasing standard deviation, and making the cache operation more accurate.}{2}{section*.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}Question 4}{2}{subsection.1.4}}
\@writefile{toc}{\contentsline {paragraph}{For both of these cases, I am guessing that the complexity is O(n*m) since the code iterates through multiple matrices and nested loops, which also contain if and else statements within them.}{2}{section*.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.5}Question 5}{2}{subsection.1.5}}
\@writefile{toc}{\contentsline {paragraph}{For this type of code to pay off, it would most likely pay off when someone is collecting data continuously in a lab setting or when someone is processing mass amounts of data. For example, for my research where I run an oscilloscope continuously through a piezoresistive sensor, I run many 'sweeps' and have to process multiple thousand data points. For experimental applications, this has high benefits and would pay off. }{2}{section*.5}}
