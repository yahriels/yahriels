
Executive Task :{I Am designing and building a GUI in PySide6 and am in the stage of developing requirements including overall/general requirements and technical requirements for an H-Reflex App}


Example Requirements:{

General GUI Interface Requirements:
Layout Structure:

The GUI shall be divided into three distinct sections aligned vertically: a top section, a middle section, and a bottom section.
Top Section (Top Third of the GUI Console):{
The system shall include a free input text slot labeled "Subject".
The system shall include a dropdown selection slot labeled "Stage".
The system shall include a dropdown selection slot labeled "Booth #".
The system shall include a free input text slot labeled "VNS".
The system shall include a free input text slot labeled "H-Amp".
The system shall include a free input text slot labeled "%" to represent a percentile value.
Data Integration Requirement:

All fields (Subject, Stage, Booth #, VNS, H-Amp, %) shall automatically pull data from a pre-existing CSV file named "H-Reflex_Metadata.csv" located in the working directory.
Manual text entry shall be disabled for these fields, relying solely on the metadata provided in the CSV file.
CSV File Structure:

The system shall use a structured file named "H-Reflex_Metadata.csv" with the following columns:
mathematica
Copy code
Subject | Stage | Booth # | VNS | H-Amp (mV) | Percentile (%) | Mode              | Reward Given (Yes/No)
--------|-------|---------|-----|------------|----------------|-------------------|-----------------------
001     | 1     | 2       | 0   | 10         | 50             | Control           | No
002     | 2     | 3       | 1   | 30         | 10             | Up-conditioning   | Yes
003     | 3     | 1       | 1   | 25         | 15             | Down-conditioning | Yes
004     | 1     | 4       | 0   | 20         | 80             | Control           | No
005     | 2     | 2       | 1   | 35         | 70             | Up-conditioning   | Yes
}

Middle Section (Middle Third of the GUI Console):{ 
Trial EMG Plot (Left Half of Console):{

The system shall include a plot labeled "Trial EMG" on the left-hand side.
The plot shall receive, store, and display EMG trial data using the matplotlib library.
The horizontal axis shall be labeled "Time (ms)", and the vertical axis labeled "EMG (mV)".
The time window of this plot shall span 150 ms, showcasing the stimulation action potential at the start of the trial.
The system shall use the emgdecomp Python library to identify spike times and individual motor unit firings (M-wave and H-wave) in each trial.
The peaks of the M-wave and H-wave shall be automatically labeled on the plot.
}

Last 50 Trials Plot (Right Half of Console):{
The system shall include a scatter plot labeled "Last 50 Trials" on the right-hand side. 
The plot shall store and display EMG data for the last 50 trials using the matplotlib library.
The horizontal axis shall be labeled "Trial #", and the vertical axis labeled "EMG (mV)".
The emgdecomp library shall be used to identify and plot spike times for the M-wave and H-wave of each trial.
The plot shall also indicate VNS stimulation points and display a success threshold line indicating successful VNS stimulation for each trial.
}
}

Bottom Section (Bottom Third of the GUI Console):{

Start/Stop Recording Button:
The system shall include a button labeled "Start/Stop Recording" that initiates the live recording process.

Filtered Live EMG Plot:{
The system shall include a plot labeled "Filtered Live EMG" that continuously receives, stores, and displays raw EMG data.
The horizontal axis of the plot shall be labeled "Time (last 5s)", and the vertical axis shall be labeled "EMG (%)".
The system shall use the emgdecomp library to identify motor unit firings and label the M-wave and H-wave peaks within the data.
The plot shall include two horizontal lines representing the Initiation Threshold.
A trial shall only be initiated and fed into the Trial EMG and Last 50 Trials plots if the raw EMG data falls within the Initiation Window (2.5-2.7s).
}
}

Performance and Technical Requirements:{
Real-Time Data Handling:
The system shall sample and display real-time EMG activity at 3000 Hz.
Latency:

Data processing and visualization must occur in real-time to ensure low-latency interaction and feedback.
Data Storage:

The system shall save the EMG trial data for each session to a local file or database.
Session Management:

Users shall be able to save and load session data from within the GUI for later review and analysis.
}
}


Project Notes: {We are modeling a H-Reflex Conditioning Operant System Architecture to create a GUI app called H-Reflex App that is heavily modeled off of this paper: Motor learning changes the axon initial segment of the spinal motoneuron (Link: https://physoc.onlinelibrary.wiley.com/doi/full/10.1113/JP283875) and this specific section to perform simultaneous recording and stimulation of Vagus Nerve Stimulation Therapy with H-Reflex Conditioning: 
Stimulus delivery and data collection were controlled by a computer that monitored soleus EMG activity (sampled at 5000 Hz) continuously for the entire period of data collection. The soleus H-reflex was elicited as follows. Whenever the absolute value (equivalent to the full-wave rectified value) of background (i.e. ongoing) EMG activity in the soleus muscle remained within a pre-defined range for a randomly varying 2.3–2.7 s period, the computer initiated a trial. The EMG range was based on the rat's typical soleus EMG level as it moved about the cage; it was typically 1–2% of the maximum possible EMG activity as assessed by the maximum M wave (i.e. the direct muscle response; Pierrot-Deseilligny & Burke, 2012). In each trial, the computer stored the most recent 50 ms of soleus EMG activity (i.e. the background EMG interval), delivered a monophasic stimulus pulse (typically 0.5 ms in duration) through the cuff on the posterior tibial nerve, and stored soleus EMG activity for the next 100 ms. Pulse amplitude was initially set just above M-wave threshold; it was subsequently automatically adjusted by the computer after each trial to maintain M-wave size unchanged throughout the entire period of data collection. Thus, the background EMG (reflecting soleus motoneuron tone at the time of H-reflex elicitation) and the M-wave (reflecting the effective strength of the nerve-cuff stimulus) remained stable throughout data collection.
Under the control mode, the computer simply digitized and stored the absolute value of EMG activity from the soleus muscle for 100 ms following nerve stimulation. Under the soleus H-reflex conditioning mode, it gave a food-pellet reward 200 ms after stimulation if EMG amplitude in the H-reflex interval (typically 6–10 ms after stimulation) was above (H-reflex up-conditioning mode) or below (H-reflex down-conditioning mode) a criterion value. The criterion was set and adjusted daily as needed so that the rat received an adequate amount of food (∼1000 pellets/day for a 500 g rat). H-reflex size was calculated as average EMG amplitude in the H-reflex interval minus average background EMG amplitude and was expressed in units of average background EMG amplitude.
Each rat was first exposed to the control mode for 20 days to determine the control H-reflex size, and then exposed to the up-conditioning (HRup rats) or down-conditioning (HRdown rats) mode for 50 days. The last 10 control-mode days and the last 10 up- or down-conditioning days (i.e. days 41–50 of conditioning) provided the data used to determine the impact of H-reflex conditioning on soleus H-reflex size. Average final (days 41–50) H-reflex size was calculated as a percentage of the control H-reflex size. Successful H-reflex conditioning was defined as a change of at least 20% in the correct direction (i.e. to ≥120% for HRup rats, to ≤80% for HRdown rats) (Wolpaw et al., 1993; Chen & Wolpaw, 1995). Thus, the rats fell into five groups: naive control (NC) rats; successful HRup (US) rats; failed HRup (UF) rats; successful HRdown (DS) rats; and failed HRdown rats (DF) rats. “

PySide6 Resources: https://www.pythonguis.com/pyside6-tutorial/
} 


Example Starter Codes
main.py:{import sys
from PySide6 import QtWidgets
from hreflex_txbdc.view.main_window import MainWindow

if __name__ == "__main__":
    #Create the QT application
    app = QtWidgets.QApplication(sys.argv)

    #Instantiate the MainWindow object
    window = MainWindow()

    #Display the main window
    window.show()

    #Turn control over to QT's main loop
    sys.exit(app.exec())



}


main_window.py:
{
from PySide6.QtWidgets import QMainWindow, QPushButton, QLabel, QVBoxLayout, QWidget
from PySide6 import QtCore
from dataclasses import dataclass, field

@dataclass
class MainWindow (QMainWindow):

    #region Private data members

    _count: int = 0

    #endregion

    #region Constructor

    def __init__ (self):
        super().__init__()

        #Create an example button
        self.button = QPushButton("Click me!")
        # Create Signal Slot which accepts the clicked signal from the QPushButton object
        self.button.clicked.connect(self.handle_button_clicked)

        #Create an example label
        self.text_label = QLabel(str(self._count), alignment=QtCore.Qt.AlignCenter)

        #Add the button and the label to a vertical box layout
        self.layout = QVBoxLayout(self)
        self.layout.addWidget(self.button)
        self.layout.addWidget(self.text_label)

        #Set the central widget of the window
        self.central_widget = QWidget()
        self.central_widget.setLayout(self.layout)
        self.setCentralWidget(self.central_widget)

        #Set the window title
        self.setWindowTitle("TxBDC H-Reflex Conditioning")
        self.resize(500, 300)
        

    #endregion

    #region Methods

    @QtCore.Slot()
    def handle_button_clicked(self) -> None:
        '''
        This method increments the count and then displays the new count.
        '''

        #Increment the count
        self._count = self._count + 1

        #Set the text of the label
        self.text_label.setText(str(self._count))

    #endregion
}


Python Code Formatting and Commenting Guidelines:
{
Please aggressively comment code. Each function should have a comment header using the Python triple-quote string comment-style. One exception to this is the __init__ function of each class doesn't really need a comment header. But all other functions should get a comment header unless there is a really good reason not to have one.
 
I also really like to use code regions. You will notice that I have already defined some code regions in my main_window.py code file. If you're unfamiliar with code regions, I'm happy to give you a brief intro. I like to use seperate out the following into their own code regions: Private data members, public data members, properties, constructors, public methods, private methods, static methods, etc...
 
Type hints: always use type hints. I am a big fan of statically typed languages, because variable types are a way of self-documenting code and making it clear what a variable is supposed to be. Unfortunately, Python is not a statically-typed language, but they have given us type hints. So always use them. If you don't know what type hints are, let me know, and I am happy to go over them with you.
}