noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate signals for each condition
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Plot signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# ARIMA Modeling and Prediction
# Convert signals to time series objects
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Stationarity Check (ADF test)
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# Fit ARIMA model and forecast
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points for each series
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecast with confidence intervals
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# RMS Fit Calculation
rmse_baseline <- accuracy(forecast_baseline)[2, "RMSE"]
rmse_down <- accuracy(forecast_down)[2, "RMSE"]
rmse_up <- accuracy(forecast_up)[2, "RMSE"]
# Linear Regression Fit
# Creating a linear model for each time series
lm_baseline <- lm(baseline_ts ~ time)
lm_down <- lm(downconditioning_ts ~ time)
lm_up <- lm(upconditioning_ts ~ time)
# Plot regression line on original data
plot_emg_with_regression <- function(signal, lm_model, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
geom_abline(intercept = coef(lm_model)[1], slope = coef(lm_model)[2], color = "red") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_with_regression(baseline_signal, lm_baseline, "Baseline with Linear Regression Fit")
plot_emg_with_regression(downconditioning_signal, lm_down, "Down-conditioning with Linear Regression Fit")
plot_emg_with_regression(upconditioning_signal, lm_up, "Up-conditioning with Linear Regression Fit")
# Peak Amplitude Tracking
peak_amplitude_baseline <- max(baseline_signal)
peak_amplitude_down <- max(downconditioning_signal)
peak_amplitude_up <- max(upconditioning_signal)
# Plot horizontal line for peak amplitude
plot_peak_amplitude <- function(signal, peak, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
geom_hline(yintercept = peak, color = "blue", linetype = "dashed") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_peak_amplitude(baseline_signal, peak_amplitude_baseline, "Baseline Peak Amplitude")
plot_peak_amplitude(downconditioning_signal, peak_amplitude_down, "Down-conditioning Peak Amplitude")
plot_peak_amplitude(upconditioning_signal, peak_amplitude_up, "Up-conditioning Peak Amplitude")
# Interpretation:
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# - **ARIMA Model Fit**: Optimal ARIMA model selection for forecasting H-reflex amplitude, with RMSE for error quantification.
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# - **ARIMA Model Fit**: Optimal ARIMA model selection for forecasting H-reflex amplitude, with RMSE for error quantification.
# - **Linear Regression Fit**: Added as an alternative trend visualization, showing linear fit across data points.
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# - **ARIMA Model Fit**: Optimal ARIMA model selection for forecasting H-reflex amplitude, with RMSE for error quantification.
# - **Linear Regression Fit**: Added as an alternative trend visualization, showing linear fit across data points.
# - **Peak Amplitude Tracking**: Using a horizontal line to track and analyze the peak amplitude of the H-reflex response, which indicates conditioning effects.
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# - **ARIMA Model Fit**: Optimal ARIMA model selection for forecasting H-reflex amplitude, with RMSE for error quantification.
# - **Linear Regression Fit**: Added as an alternative trend visualization, showing linear fit across data points.
# - **Peak Amplitude Tracking**: Using a horizontal line to track and analyze the peak amplitude of the H-reflex response, which indicates conditioning effects.
# - **Forecast Accuracy**: RMSE values provide an accuracy metric; smaller RMSE indicates more accurate model predictions.
# Interpretation:
# - **ADF Test**: Assesses stationarity, required for valid ARIMA modeling. A significant p-value (p < 0.05) indicates a stationary series.
# - **ARIMA Model Fit**: Optimal ARIMA model selection for forecasting H-reflex amplitude, with RMSE for error quantification.
# - **Linear Regression Fit**: Added as an alternative trend visualization, showing linear fit across data points.
# - **Peak Amplitude Tracking**: Using a horizontal line to track and analyze the peak amplitude of the H-reflex response, which indicates conditioning effects.
# - **Forecast Accuracy**: RMSE values provide an accuracy metric; smaller RMSE indicates more accurate model predictions.
library(forecast)
library(tseries)
# Parameters
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal data for H-Reflex conditioning
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
# M-Wave generation
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
# H-Wave generation with conditioning effect
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2) * h_wave_amplitude
# Combined EMG signal
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate signals for each conditioning type
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Time Series Conversion for Forecasting
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# ADF Test for Stationarity
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Model Fitting and Prediction
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecasting the next 5 observations
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasts
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# RMS Fit Calculation
rmse_baseline <- accuracy(forecast_baseline)[2, "RMSE"]
rmse_down <- accuracy(forecast_down)[2, "RMSE"]
rmse_up <- accuracy(forecast_up)[2, "RMSE"]
# Linear Regression Fit
linear_model <- lm(baseline_signal ~ time)
summary(linear_model)
# Add horizontal line at peak amplitude of the H-Wave for comparison
peak_amplitude <- max(baseline_signal)
plot(time, baseline_signal, type = "l", col = "blue", main = "Baseline with Peak Amplitude Line")
abline(h = peak_amplitude, col = "red", lty = 2)
# Decomposition of Baseline Time Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# Statistical Interpretations for Presentation
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# 3. **RMSE (Root Mean Square Error)**: Lower RMSE values indicate better predictive accuracy of the model.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# 3. **RMSE (Root Mean Square Error)**: Lower RMSE values indicate better predictive accuracy of the model.
# 4. **Linear Regression Summary**: Examines the trend in baseline data over time.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# 3. **RMSE (Root Mean Square Error)**: Lower RMSE values indicate better predictive accuracy of the model.
# 4. **Linear Regression Summary**: Examines the trend in baseline data over time.
# 5. **Peak Amplitude Line**: Assists in visualizing significant amplitude changes across conditions.
# Parameters
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate synthetic EMG signal data
generate_emg_signal <- function(condition = "baseline") {
# Define the EMG stimulus signal parameters
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
# M-Wave Component
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
# H-Wave Component with amplitude adjusted by conditioning type
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
# Total EMG Signal
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate signals for each conditioning type
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Visualize signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert signals to time series (10 observations for example)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check for stationarity with ADF test
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# Fit ARIMA models
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasts
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# RMSE calculation for model evaluation
rmse_baseline <- accuracy(forecast_baseline)[2, "RMSE"]
rmse_down <- accuracy(forecast_down)[2, "RMSE"]
rmse_up <- accuracy(forecast_up)[2, "RMSE"]
# RMSE calculation for model evaluation
rmse_baseline <- accuracy(forecast_baseline)[1, "RMSE"]
rmse_down <- accuracy(forecast_down)[1, "RMSE"]
rmse_up <- accuracy(forecast_up)[1, "RMSE"]
# Plotting horizontal line for H-Reflex peak amplitude
baseline_peak <- max(baseline_signal)
down_peak <- max(downconditioning_signal)
up_peak <- max(upconditioning_signal)
# Overlay peaks on plot
plot_emg_signal(baseline_signal, "Baseline Signal with Peak Amplitude") + geom_hline(yintercept = baseline_peak, linetype = "dashed", color = "red")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal with Peak Amplitude") + geom_hline(yintercept = down_peak, linetype = "dashed", color = "red")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal with Peak Amplitude") + geom_hline(yintercept = up_peak, linetype = "dashed", color = "red")
# Optional: Linear regression for trends in H-Reflex peak amplitude
baseline_df <- data.frame(Time = time, EMG_Signal = baseline_signal)
lm_fit <- lm(EMG_Signal ~ Time, data = baseline_df)
summary(lm_fit) # Check significance of trend slope
# Interpretation:
# Interpretation:
# - Regression slope assesses if there’s a trend in baseline EMG over time.
# Statistical Interpretations for Presentation
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# 3. **RMSE (Root Mean Square Error)**: Lower RMSE values indicate better predictive accuracy of the model.
# Statistical Interpretations for Presentation
# 1. **ADF Test Results**: If p < 0.05, the data is stationary, allowing for consistent modeling.
# 2. **ARIMA Model Fit**: Adjusted based on ADF and autocorrelation tests to optimize prediction accuracy.
# 3. **RMSE (Root Mean Square Error)**: Lower RMSE values indicate better predictive accuracy of the model.
# 4. **Linear Regression Summary**: Examines the trend in baseline data over time.
# Load necessary libraries
library(ggplot2)
library(forecast)
library(tseries)
# Parameters
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal data for H-Reflex conditioning
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
# M-Wave generation
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
# H-Wave generation with conditioning effect
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2) * h_wave_amplitude
# Combined EMG signal
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate signals for each conditioning type
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Time Series Conversion for Forecasting
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# ADF Test for Stationarity
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Model Fitting and Prediction
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecasting the next 5 observations
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasts
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# RMS Fit Calculation
rmse_baseline <- accuracy(forecast_baseline)[2, "RMSE"]
rmse_down <- accuracy(forecast_down)[2, "RMSE"]
rmse_up <- accuracy(forecast_up)[2, "RMSE"]
# Linear Regression Fit
linear_model <- lm(baseline_signal ~ time)
summary(linear_model)
# Add horizontal line at peak amplitude of the H-Wave for comparison
peak_amplitude <- max(baseline_signal)
plot(time, baseline_signal, type = "l", col = "blue", main = "Baseline with Peak Amplitude Line")
abline(h = peak_amplitude, col = "red", lty = 2)
# Decomposition of Baseline Time Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
library(forecast)
library(tseries)
# Set parameters for EMG data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds (H-reflex duration)
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate H-Reflex EMG signal based on conditioning state
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate and visualize EMG signals for each condition
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Plot EMG signals for visual comparison
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert to time series objects (simulate 10 observations per interval)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check for stationarity (ADF test)
# Interpretation: If p < 0.05, we reject H₀ (data is stationary)
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# Fit ARIMA model for each time series
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points and plot predictions
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plotting forecasts
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# Decomposition analysis of Prediction Time Series
predict_signal <- generate_emg_signal("baseline")  # Simulate prediction data
predict_ts <- ts(predict_signal, frequency = 10)
decomp_predict <- decompose(predict_ts)
plot(decomp_predict)
# RMS and Linear Fit Analysis
rms_fit <- sqrt(mean((predict_signal - mean(predict_signal))^2))  # Calculate RMS
fit_linear <- lm(predict_signal ~ time)  # Linear Regression Fit
# Plotting RMS, Linear Fit, and Peak Amplitude
ggplot(data.frame(Time = time * 1000, EMG_Signal = predict_signal), aes(x = Time, y = EMG_Signal)) +
geom_line() +
geom_hline(yintercept = max(predict_signal), color = "blue", linetype = "dashed", size = 1) +
geom_abline(intercept = coef(fit_linear)[1], slope = coef(fit_linear)[2], color = "red") +
ggtitle("RMS and Linear Fit with Peak Amplitude Highlight") +
labs(x = "Time (ms)", y = "Amplitude (mV)") +
theme_minimal()
# Statistical Interpretation
# Statistical Interpretation
# - RMS Fit: Represents signal amplitude variability, indicating reflex response magnitude.
# Statistical Interpretation
# - RMS Fit: Represents signal amplitude variability, indicating reflex response magnitude.
# - Linear Fit: Identifies signal trend, useful for observing conditioning effects.
# Load required libraries
library(ggplot2)
library(forecast)
library(tseries)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Visualize EMG signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert signals to time series (sampling frequency 10 Hz for demonstration)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Modeling and Forecasting
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasted results
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# Decomposition Analysis for Baseline Prediction Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# Statistical Interpretation of Tests and Analysis
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# ARIMA Model Fit: Automatically selects the best-fitting ARIMA model for prediction.
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# ARIMA Model Fit: Automatically selects the best-fitting ARIMA model for prediction.
# Forecast Results: Forecast future H-reflex amplitudes based on past data.
