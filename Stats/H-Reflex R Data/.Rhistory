ggplot(data.frame(Time = time * 1000, EMG_Signal = predict_signal), aes(x = Time, y = EMG_Signal)) +
geom_line() +
geom_hline(yintercept = max(predict_signal), color = "blue", linetype = "dashed", size = 1) +
geom_abline(intercept = coef(fit_linear)[1], slope = coef(fit_linear)[2], color = "red") +
ggtitle("RMS and Linear Fit with Peak Amplitude Highlight") +
labs(x = "Time (ms)", y = "Amplitude (mV)") +
theme_minimal()
# Statistical Interpretation
# Statistical Interpretation
# - RMS Fit: Represents signal amplitude variability, indicating reflex response magnitude.
# Statistical Interpretation
# - RMS Fit: Represents signal amplitude variability, indicating reflex response magnitude.
# - Linear Fit: Identifies signal trend, useful for observing conditioning effects.
# Load required libraries
library(ggplot2)
library(forecast)
library(tseries)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Visualize EMG signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert signals to time series (sampling frequency 10 Hz for demonstration)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Modeling and Forecasting
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasted results
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# Decomposition Analysis for Baseline Prediction Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# Statistical Interpretation of Tests and Analysis
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# ARIMA Model Fit: Automatically selects the best-fitting ARIMA model for prediction.
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# ARIMA Model Fit: Automatically selects the best-fitting ARIMA model for prediction.
# Forecast Results: Forecast future H-reflex amplitudes based on past data.
# Load required libraries
library(ggplot2)
library(forecast)
library(tseries)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Visualize EMG signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert signals to time series (sampling frequency 10 Hz for demonstration)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# Load required libraries
library(ggplot2)
library(forecast)
library(tseries)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Visualize EMG signals
plot_emg_signal <- function(signal, title) {
emg_data <- data.frame(Time = time * 1000, EMG_Signal = signal)
ggplot(emg_data, aes(x = Time, y = EMG_Signal)) +
geom_line(color = "black") +
labs(x = "Time (ms)", y = "Amplitude (mV)", title = title) +
theme_minimal() +
theme(panel.grid.major = element_line(color = "gray", linetype = "dashed"))
}
plot_emg_signal(baseline_signal, "Baseline Signal")
plot_emg_signal(downconditioning_signal, "Down-conditioning Signal")
plot_emg_signal(upconditioning_signal, "Up-conditioning Signal")
# Convert signals to time series (sampling frequency 10 Hz for demonstration)
baseline_ts <- ts(baseline_signal, frequency = 10)
downconditioning_ts <- ts(downconditioning_signal, frequency = 10)
upconditioning_ts <- ts(upconditioning_signal, frequency = 10)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Modeling and Forecasting
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasted results
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# Decomposition Analysis for Baseline Prediction Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# Statistical Interpretation of Tests and Analysis
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# Statistical Interpretation of Tests and Analysis
# ADF Test Results: If p < 0.05, we reject the null hypothesis, indicating stationarity.
# ARIMA Model Fit: Automatically selects the best-fitting ARIMA model for prediction.
# Load necessary libraries
library(ggplot2)
library(forecast)
library(tseries)
# Generate synthetic EMG signal data (for demonstration)
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal data
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate signals for analysis
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
# Convert signals to time series
baseline_ts <- ts(baseline_signal, frequency = 1000)
downconditioning_ts <- ts(downconditioning_signal, frequency = 1000)
# 1. Stationarity Check using Augmented Dickey-Fuller (ADF) Test
adf_test_baseline <- adf.test(baseline_ts, alternative = "stationary")
adf_test_downconditioning <- adf.test(downconditioning_ts, alternative = "stationary")
# 2. Autocorrelation Analysis
acf(baseline_ts, main = "ACF of Baseline EMG Signal")
pacf(baseline_ts, main = "PACF of Baseline EMG Signal")
# 3. Paired t-test for Mean Comparison
pre_post_t_test <- t.test(baseline_signal, downconditioning_signal, paired = TRUE)
# 4. Confidence Intervals for Mean H-Reflex Amplitude
conf_interval_baseline <- t.test(baseline_signal)$conf.int
conf_interval_downconditioning <- t.test(downconditioning_signal)$conf.int
# 5. Time Series Decomposition (Additive and Multiplicative)
# Decompose additive
baseline_decomp_additive <- decompose(baseline_ts, type = "additive")
plot(baseline_decomp_additive, main = "Additive Decomposition of Baseline Signal")
# Decompose multiplicative
baseline_decomp_multiplicative <- decompose(baseline_ts, type = "multiplicative")
plot(baseline_decomp_multiplicative, main = "Multiplicative Decomposition of Baseline Signal")
# 6. ARIMA Model for Forecasting
arima_model <- auto.arima(baseline_ts)
forecasted_values <- forecast(arima_model, h = 50)
plot(forecasted_values, main = "ARIMA Forecast of Baseline Signal")
# Displaying all test results
print(list(
"ADF Test Baseline" = adf_test_baseline,
"ADF Test Downconditioning" = adf_test_downconditioning,
"Pre-Post T-test" = pre_post_t_test,
"Confidence Interval Baseline" = conf_interval_baseline,
"Confidence Interval Downconditioning" = conf_interval_downconditioning
))
# Load necessary libraries
library(ggplot2)
library(forecast)
library(tseries)
# Generate EMG Time Series Data
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate baseline and conditioned signals
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Convert to time series object
baseline_ts <- ts(baseline_signal, frequency = sampling_rate)
downconditioning_ts <- ts(downconditioning_signal, frequency = sampling_rate)
upconditioning_ts <- ts(upconditioning_signal, frequency = sampling_rate)
# 1. Check Stationarity using ADF test
adf_test_baseline <- adf.test(baseline_ts)
adf_test_downconditioning <- adf.test(downconditioning_ts)
adf_test_upconditioning <- adf.test(upconditioning_ts)
print(adf_test_baseline)
print(adf_test_downconditioning)
print(adf_test_upconditioning)
# 2. Autocorrelation Analysis
acf(baseline_ts, main = "Autocorrelation of Baseline H-reflex")
acf(downconditioning_ts, main = "Autocorrelation of Downconditioning H-reflex")
acf(upconditioning_ts, main = "Autocorrelation of Upconditioning H-reflex")
# 3. Mean Comparison using Paired T-Test
mean_pre <- mean(baseline_signal)
mean_post <- mean(downconditioning_signal)
t_test <- t.test(baseline_signal, downconditioning_signal, paired = TRUE)
print(t_test)
# 4. Confidence Interval for Mean
ci_baseline <- mean(baseline_signal) + c(-1, 1) * qt(0.975, length(baseline_signal) - 1) * sd(baseline_signal) / sqrt(length(baseline_signal))
ci_downconditioning <- mean(downconditioning_signal) + c(-1, 1) * qt(0.975, length(downconditioning_signal) - 1) * sd(downconditioning_signal) / sqrt(length(downconditioning_signal))
print(ci_baseline)
print(ci_downconditioning)
# 5. Decomposition Analysis (Additive and Multiplicative)
decomp_add <- decompose(baseline_ts, type = "additive")
# 5. Decomposition Analysis (Additive and Multiplicative)
decomp_add <- decompose(baseline_ts, type = "additive")
decomp_mult <- decompose(baseline_ts, type = "multiplicative")
plot(decomp_add)
plot(decomp_mult)
# 6. ARIMA Forecasting
fit_arima <- auto.arima(baseline_ts)
forecast_arima <- forecast(fit_arima, h = 50)
plot(forecast_arima, main = "ARIMA Forecast for Baseline Signal")
# Conclusions
if (t_test$p.value < 0.05) {
print("Significant effect of conditioning on H-reflex amplitude.")
} else {
print("No significant effect of conditioning on H-reflex amplitude.")
}
# Load necessary libraries
library(ggplot2)
library(forecast)
library(tseries)
# Generate EMG Time Series Data
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate baseline and conditioned signals
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Convert to time series object
baseline_ts <- ts(baseline_signal, frequency = sampling_rate)
downconditioning_ts <- ts(downconditioning_signal, frequency = sampling_rate)
upconditioning_ts <- ts(upconditioning_signal, frequency = sampling_rate)
# 1. Check Stationarity using ADF test
adf_test_baseline <- adf.test(baseline_ts)
adf_test_downconditioning <- adf.test(downconditioning_ts)
adf_test_upconditioning <- adf.test(upconditioning_ts)
print(adf_test_baseline)
print(adf_test_downconditioning)
print(adf_test_upconditioning)
# 2. Autocorrelation Analysis
acf(baseline_ts, main = "Autocorrelation of Baseline H-reflex")
acf(downconditioning_ts, main = "Autocorrelation of Downconditioning H-reflex")
acf(upconditioning_ts, main = "Autocorrelation of Upconditioning H-reflex")
# 3. Mean Comparison using Paired T-Test
mean_pre <- mean(baseline_signal)
mean_post <- mean(downconditioning_signal)
t_test <- t.test(baseline_signal, downconditioning_signal, paired = TRUE)
print(t_test)
# 4. Confidence Interval for Mean
ci_baseline <- mean(baseline_signal) + c(-1, 1) * qt(0.975, length(baseline_signal) - 1) * sd(baseline_signal) / sqrt(length(baseline_signal))
ci_downconditioning <- mean(downconditioning_signal) + c(-1, 1) * qt(0.975, length(downconditioning_signal) - 1) * sd(downconditioning_signal) / sqrt(length(downconditioning_signal))
print(ci_baseline)
print(ci_downconditioning)
# 5. Decomposition Analysis (Additive and Multiplicative)
decomp_add <- decompose(baseline_ts, type = "additive")
decomp_mult <- decompose(baseline_ts, type = "multiplicative")
plot(decomp_add)
plot(decomp_mult)
# 6. ARIMA Forecasting
fit_arima <- auto.arima(baseline_ts)
forecast_arima <- forecast(fit_arima, h = 50)
plot(forecast_arima, main = "ARIMA Forecast for Baseline Signal")
# Conclusions
if (t_test$p.value < 0.05) {
print("Significant effect of conditioning on H-reflex amplitude.")
} else {
print("No significant effect of conditioning on H-reflex amplitude.")
}
library(forecast)
library(tseries)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Convert signals to time series
baseline_ts <- ts(baseline_signal, frequency = 100)
downconditioning_ts <- ts(downconditioning_signal, frequency = 100)
upconditioning_ts <- ts(upconditioning_signal, frequency = 100)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)       # Null Hypothesis: non-stationary
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Modeling and Forecasting
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasted results
autoplot(forecast_baseline) + ggtitle("Baseline Forecast") + theme_minimal()
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast") + theme_minimal()
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast") + theme_minimal()
# Decomposition Analysis for Baseline Prediction Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# Parameters for simulated data generation
sampling_rate <- 10000   # samples per second
duration <- 0.02         # 20 milliseconds
time <- seq(0, duration, length.out = sampling_rate * duration + 1)
# Function to generate EMG signal with different conditioning states
generate_emg_signal <- function(condition = "baseline") {
stimulus_start <- round(0.002 * sampling_rate)
stimulus_duration <- round(0.0002 * sampling_rate)
stimulus_signal <- rep(0, length(time))
stimulus_signal[stimulus_start:(stimulus_start + stimulus_duration - 1)] <- 1
m_wave_center <- round(0.006 * sampling_rate)
m_wave_std <- 0.0007 * sampling_rate
m_wave <- exp(-0.55 * ((time * sampling_rate - m_wave_center) / m_wave_std)^2)
h_wave_center <- round(0.0201 * sampling_rate)
h_wave_std <- 0.00025 * sampling_rate
h_wave_amplitude <- ifelse(condition == "baseline", 1, ifelse(condition == "downconditioning", 0.7, 1.3))
h_wave <- exp(-0.5 * ((time * sampling_rate - h_wave_center) / h_wave_std)^2)
emg_signal <- stimulus_signal - m_wave * 0.30 + h_wave * h_wave_amplitude
noise <- rnorm(length(emg_signal), mean = 0, sd = 0.1)
return(emg_signal + noise)
}
# Generate data for baseline, down-conditioning, and up-conditioning
baseline_signal <- generate_emg_signal("baseline")
downconditioning_signal <- generate_emg_signal("downconditioning")
upconditioning_signal <- generate_emg_signal("upconditioning")
# Convert signals to time series
baseline_ts <- ts(baseline_signal, frequency = 500)
downconditioning_ts <- ts(downconditioning_signal, frequency = 500)
upconditioning_ts <- ts(upconditioning_signal, frequency = 500)
# Check stationarity with Augmented Dickey-Fuller Test
adf.test(baseline_ts)
adf.test(downconditioning_ts)
adf.test(upconditioning_ts)
# ARIMA Modeling and Forecasting
fit_baseline <- auto.arima(baseline_ts)
fit_down <- auto.arima(downconditioning_ts)
fit_up <- auto.arima(upconditioning_ts)
# Forecast next 5 time points
forecast_baseline <- forecast(fit_baseline, h = 5)
forecast_down <- forecast(fit_down, h = 5)
forecast_up <- forecast(fit_up, h = 5)
# Plot forecasted results
autoplot(forecast_baseline) + ggtitle("Baseline Forecast")
autoplot(forecast_down) + ggtitle("Down-conditioning Forecast")
autoplot(forecast_up) + ggtitle("Up-conditioning Forecast")
# Decomposition Analysis for Baseline Prediction Series
decomp_baseline <- decompose(baseline_ts)
plot(decomp_baseline)
# RMS Fit and Linear Regression Fit
rms_fit <- sqrt(mean(baseline_ts^2))
linear_fit <- lm(baseline_ts ~ time)
summary(linear_fit)
# Plotting the H-Wave Peak
plot(baseline_ts, type = 'l', col = 'blue', main = "H-Reflex Baseline with Peak Line", ylab = "Amplitude (mV)")
abline(h = max(baseline_signal), col = "red", lty = 2)  # Horizontal line at peak amplitude
